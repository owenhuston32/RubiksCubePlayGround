<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Rubik's Cube PlayGround</title>
    <link rel="stylesheet" href="main.css">
</head>

<body>

    <script src="js/three.min.js"></script>

   <script>
// global var's
var scene, renderer, mainCamera;
var raycaster = new THREE.Raycaster();
var cameras = [], colorChangeArray = [], positions = [];
var materials = [
    new THREE.MeshPhongMaterial({color: 'white'})
,new THREE.MeshPhongMaterial({color: 'yellow'})
,new THREE.MeshPhongMaterial({color: 'green'})
,new THREE.MeshPhongMaterial({color: 'blue'})
,new THREE.MeshPhongMaterial({color: 'red'})
,new THREE.MeshPhongMaterial({color: 0xFF8C00})
]
var mouseUp = true;
init();

function init()
{
	
    container = document.createElement( 'div' );
    
    clock = new THREE.Clock();
    
    viewSize = 6;
    
    renderer = new THREE.WebGLRenderer( { antialias: true } );

    originalAspect = renderer.width / renderer.height;

    setupCameras();

    container.appendChild( renderer.domElement );
    
    document.body.appendChild (container);

    scene = new THREE.Scene();
    scene.background = new THREE.Color( 0xf0f0f0 );


    const resizeObserver = new ResizeObserver(onWindowResize);
    resizeObserver.observe(renderer.domElement, {box: 'content-box'});
    

    //fullCube = createCube();
    var directionalLight = new THREE.DirectionalLight( 0xffffff, 1.2 );
    directionalLight.position.x = 2;
    directionalLight.position.z = 2;
    //directionalLight.target = fullCube;
    scene.add( directionalLight );
    const ambientLight = new THREE.AmbientLight (0x11111, 1);
    scene.add(ambientLight);    

    window.addEventListener ('resize', onWindowResize(originalAspect, viewSize), false);

    document.onmousedown = function(){onMouseDown(event)};

    document.onmousemove = function(){onMouseMove(event)};

    document.onmouseup = function(){onMouseUp()};
    
    animate();
}
function setupCameras()
{
    for(var i=0;i<4;i++)
    {
        var subCamera = new THREE.OrthographicCamera (-originalAspect*viewSize/2, originalAspect * viewSize/2, viewSize/2, -viewSize/2,-1000,1000);
        if(i==0)
        {
            //top
               subCamera.position.y = 7;
               subCamera.lookAt (new THREE.Vector3(0,0,0));
               subCamera.position.z = -.75;
               subCamera.position.x = -.5;

               }
           else if(i==1)
               {
               //isometric
                subCamera.position.x = 14;
                subCamera.position.z = 15;
                subCamera.position.y = -6;
                subCamera.lookAt (new THREE.Vector3(0,0,0));

               }
           else if(i==2)
               {
               //side
               subCamera.position.z = 5;
               subCamera.lookAt (new THREE.Vector3(0,0,0));
               subCamera.position.x = -.5
               
               }
           else
               {
               //front
              subCamera.position.x = 6;
              subCamera.lookAt (new THREE.Vector3(0,0,0));
              subCamera.position.y = 0;
              subCamera.position.z = -.5;

               }

            subCamera.name  = "camera: " + i;
           cameras.push(subCamera);
        }
}
function animate()
{
    requestAnimationFrame ( animate );  
    render();  
}

function getMousePosition(mouse)
{
    mouse.x = ( event.offsetX / window.innerWidth) * 2 - 1;
    mouse.y = - ( event.offsetY / window.innerHeight) * 2 + 1;

    return mouse;
}

// figure out which corner of the screen was clicked
function getCornerClicked(mouse)
{
    if(mouse.x < window.innerWidth / 2)
    {
        if(mouse.y < window.innerHeight / 2)
        {
            //top left
            return 0;
        }
        else
        {
            // bottom left
            return 2;
        }
    }
    else
    {
        if(mouse.y < window.innerHeight / 2)
        {
            //top right
            return 1;
        }
        else
        {
            // bottom right
            return 3;
        }
    }
}

// converts mouse position to x and y to be between (-1, 1)
function projectMouseToCorner(cornerClicked, currentMouse)
{
    newMouse = new THREE.Vector2();
    newMouse.x = currentMouse.x;
    newMouse.y = currentMouse.y;

    //NewValue = (((OldValue - OldMin) * (NewMax - NewMin)) / (OldMax - OldMin)) + NewMin
    // moving mouse to new corner

    // clicked on the right side of the screen
    if(cornerClicked == 1 || cornerClicked == 3)
    {
        newMouse.x = (((currentMouse.x - window.innerWidth / 2) * 2) / (window.innerWidth / 2)) -1;
    }
    // clicked on left side of the screen
    else
    {
        newMouse.x = (currentMouse.x  * 2) / (window.innerWidth / 2) - 1;
    }
    //clicked bottom half of the screen
    if(cornerClicked == 2 || cornerClicked == 3)
    {
        newMouse.y = ((currentMouse.y - window.innerHeight / 2) * 2) / (window.innerHeight / 2) - 1;
    }
    // clicked on top half of the screen
    else
    {
        newMouse.y = ((currentMouse.y * 2) / (window.innerHeight / 2)) - 1;
    }

    return newMouse;
}

function onMouseDown(event)
{
    mouseUp = false;
    event.preventDefault();

    var currentMouse = getMousePosition(event);

    prevX = currentMouse.x;
    prevY = currentMouse.y;

    var cornerClicked = getCornerClicked(currentMouse);

    currentMouse = projectMouseToCorner(cornerClicked, currentMouse);

    mainCamera = cameras[cornerClicked];

    raycaster.setFromCamera(currentMouse, mainCamera);

    var intersects = raycaster.intersectObjects( scene.children, true );
    
    if ( intersects.length > 0 ) 
    {
        var intersection = intersects[ 0 ];
        pressedObject = intersection.object;
        
        console.log(intersection.object);
    }
}

function onMouseMove(event)
{
    if (mouseUp) { return; }
    
    mouse = getMousePosition(event);

    var moveHorizontal = false, moveVertical = false;

    var xDragDistance = Math.abs(prevX - mouse.x);
    var yDragDistance = Math.abs(prevY - mouse.y);

    // minimum distance to be considered dragging
    var minDragDistance = 0.05;

    if(xDragDistance >= minDragDistance || yDragDistance >= minDragDistance)
    {
        //check if youre dragging horizonally or vertically
        if(yDragDistance > xDragDistance)
        {
            moveVertical=true;
        }
        else
        {
            moveHorizontal = true;
        }
        //calculateMove(moveHorizontal, moveVertical);
        //ActivateSide();
    }
}

function onMouseUp()
{

    mouseUp = true;



}

function onWindowResize()
{

    const canvas = renderer.domElement;
    // look up the size the canvas is being displayed
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    var aspect = width / height;
    var change = originalAspect / aspect;
    var newSize = viewSize * change;
    
    renderer.setSize(width, height, false);
}

function render()
{   
    const canvas = renderer.domElement;
    // look up the size the canvas is being displayed

    var SCREEN_W = canvas.clientWidth, SCREEN_H = canvas.clientHeight;

    var left,bottom, width, height;

    left = 1; bottom = 0.5*SCREEN_H; width = 0.5*SCREEN_W-1; height = 0.5*SCREEN_H;
    setupCamera(left, bottom, width, height, renderer, cameras[0]);

    left = 0.5*SCREEN_W+1; bottom = 0.5*SCREEN_H; width = 0.5*SCREEN_W-2; height = 0.5*SCREEN_H;
    setupCamera(left, bottom, width, height, renderer, cameras[1]);
   
    left = 1; bottom = 1; width = 0.5*SCREEN_W-1; height = 0.5*SCREEN_H-2;
    setupCamera(left, bottom, width, height, renderer, cameras[2]);
    
    left = 0.5*SCREEN_W+1; bottom = 1; width = 0.5*SCREEN_W-2; height = 0.5*SCREEN_H-2;
    setupCamera(left, bottom, width, height, renderer, cameras[3]);
    
}
function setupCamera(left, bottom, width, height, renderer, camera)
{
    renderer.setViewport (left,bottom,width,height);
    renderer.setScissor(left,bottom,width,height);
    renderer.setScissorTest( true );
    camera.updateProjectionMatrix();
    renderer.render (scene,camera);
}


</script>


</body>

</html>